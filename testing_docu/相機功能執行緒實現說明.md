# 相機功能執行緒實現說明

## 概述

本系統的相機功能採用多執行緒架構，確保 UI 響應性和處理效率。本文檔詳細說明相機功能的執行緒實現方式。

## 架構設計

### 1. 執行緒模型

相機功能採用 **生產者-消費者模式** 和 **事件驅動模式** 的混合架構：

```
┌─────────────────┐
│  AForge.Video   │  ← 相機硬體驅動（獨立執行緒）
│  VideoCapture   │
└────────┬────────┘
         │ NewFrame 事件
         ▼
┌─────────────────┐
│ 事件處理執行緒   │  ← UI 執行緒（InvokeUI）
│ (NewFrame)      │
└────────┬────────┘
         │
         ├─→ 更新預覽畫面（UI 執行緒）
         │
         └─→ 拍照/連拍處理（背景執行緒）
                │
                ▼
         ┌─────────────────┐
         │ 推論處理執行緒   │  ← 使用 SemaphoreSlim 控制並發
         │ (Yolo 推論)     │
         └─────────────────┘
```

### 2. 核心組件

#### 2.1 相機連接管理

**執行緒：UI 執行緒**

```csharp
private VideoCaptureDevice? _videoSource;
private FilterInfoCollection? _videoDevices;
```

- `_videoSource`: 相機設備實例，由 AForge.Video 管理
- `_videoDevices`: 可用相機列表，在主執行緒中枚舉

**連接流程：**
1. 用戶點擊「連接相機」按鈕（UI 執行緒）
2. 創建 `VideoCaptureDevice` 實例（UI 執行緒）
3. 註冊 `NewFrame` 事件處理器（UI 執行緒）
4. 啟動相機（AForge 內部啟動獨立執行緒）

#### 2.2 畫面預覽

**執行緒：混合執行緒**

```csharp
private Bitmap? _currentCameraFrame;
private readonly object _cameraFrameLock = new object();
```

**執行流程：**

1. **AForge 執行緒**（相機硬體驅動）
   - 持續從相機獲取畫面
   - 觸發 `NewFrame` 事件

2. **事件處理執行緒**（可能是 AForge 內部執行緒）
   ```csharp
   _videoSource.NewFrame += (sender, eventArgs) =>
   {
       // 1. 複製畫面到線程安全的緩衝區
       lock (_cameraFrameLock)
       {
           _currentCameraFrame?.Dispose();
           _currentCameraFrame = (Bitmap)eventArgs.Frame.Clone();
       }
       
       // 2. 更新 UI（切換到 UI 執行緒）
       InvokeUI(() =>
       {
           resultPictureBox.Image = previewFrame;
       });
   };
   ```

3. **UI 執行緒**（透過 `InvokeUI`）
   - 更新 `resultPictureBox` 顯示預覽畫面
   - 確保線程安全

**線程安全機制：**
- 使用 `lock (_cameraFrameLock)` 保護共享的 `_currentCameraFrame`
- 使用 `InvokeUI()` 確保 UI 更新在主執行緒執行

#### 2.3 拍照檢測

**執行緒：UI 執行緒 + 背景執行緒**

```csharp
private async void BtnCaptureCamera_Click(object? sender, EventArgs e)
{
    // 1. UI 執行緒：驗證狀態
    if (_videoSource == null || !_videoSource.IsRunning)
        return;
    
    // 2. UI 執行緒：獲取畫面快照
    Bitmap? frameToProcess = null;
    lock (_cameraFrameLock)
    {
        if (_currentCameraFrame != null)
        {
            frameToProcess = (Bitmap)_currentCameraFrame.Clone();
        }
    }
    
    // 3. 背景執行緒：處理圖片
    using var skBitmap = BitmapToSKBitmap(frameToProcess);
    await ProcessCameraImage(skBitmap, "CameraCapture");
}
```

**執行流程：**

1. **UI 執行緒**
   - 驗證相機連接狀態
   - 從線程安全的緩衝區複製畫面
   - 啟動異步處理任務

2. **背景執行緒**（`ProcessCameraImage`）
   - 轉換圖片格式（Bitmap → SKBitmap）
   - 執行 Yolo 推論（受 `_inferenceGate` 保護）
   - 繪製檢測結果
   - 保存結果圖片

#### 2.4 連拍檢測

**執行緒：UI 執行緒 + 多個背景執行緒**

```csharp
private async void BtnBurstCapture_Click(object? sender, EventArgs e)
{
    var processTaskList = new List<Task>();
    
    for (int i = 0; i < burstCount; i++)
    {
        // 1. UI 執行緒：獲取畫面
        Bitmap? currentFrame = null;
        lock (_cameraFrameLock)
        {
            if (_currentCameraFrame != null)
            {
                currentFrame = (Bitmap)_currentCameraFrame.Clone();
            }
        }
        
        // 2. 創建異步處理任務（不阻塞拍攝循環）
        var processTask = Task.Run(async () =>
        {
            using var skBitmap = BitmapToSKBitmap(frame);
            await ProcessCameraImage(skBitmap, $"CameraBurst_{i}");
        });
        
        processTaskList.Add(processTask);
        
        // 3. 等待到正確的時間點（1 秒內均勻分布）
        await Task.Delay(calculatedInterval);
    }
    
    // 4. 等待所有處理任務完成
    await Task.WhenAll(processTaskList);
}
```

**執行流程：**

1. **UI 執行緒**
   - 在 1 秒內按時間間隔獲取多張畫面
   - 為每張畫面創建獨立的處理任務
   - 不等待處理完成，繼續拍攝下一張

2. **多個背景執行緒**（並行處理）
   - 每個任務獨立處理一張圖片
   - 使用 `_cameraSaveSemaphore` 控制保存操作的並發數
   - 使用 `_inferenceGate` 確保 Yolo 推論的線程安全

**並發控制：**

```csharp
// 推論門閥：確保 Yolo 推論在同一時間只有一個執行緒執行
private readonly SemaphoreSlim _inferenceGate = new(1, 1);

// 保存操作信號量：控制同時保存的圖片數量
private readonly SemaphoreSlim _cameraSaveSemaphore = 
    new SemaphoreSlim(Environment.ProcessorCount, Environment.ProcessorCount);
```

### 3. 線程安全機制

#### 3.1 畫面緩衝區保護

```csharp
private Bitmap? _currentCameraFrame;
private readonly object _cameraFrameLock = new object();

// 寫入（AForge 事件執行緒）
lock (_cameraFrameLock)
{
    _currentCameraFrame?.Dispose();
    _currentCameraFrame = (Bitmap)eventArgs.Frame.Clone();
}

// 讀取（UI 執行緒或背景執行緒）
lock (_cameraFrameLock)
{
    if (_currentCameraFrame != null)
    {
        frameToProcess = (Bitmap)_currentCameraFrame.Clone();
    }
}
```

#### 3.2 UI 更新保護

```csharp
private void InvokeUI(Action action)
{
    if (InvokeRequired)
    {
        Invoke(action);
    }
    else
    {
        action();
    }
}
```

所有 UI 更新都必須透過 `InvokeUI()` 方法，確保在主執行緒執行。

#### 3.3 推論線程安全

```csharp
// 推論門閥：避免多執行緒同時推論
private readonly SemaphoreSlim _inferenceGate = new(1, 1);

// 在推論前獲取鎖
await _inferenceGate.WaitAsync();
try
{
    results = _yolo!.RunSegmentation(skBitmap, ...);
}
finally
{
    _inferenceGate.Release();
}
```

**為什麼需要推論門閥？**
- Yolo 模型可能不是線程安全的
- 避免多個執行緒同時訪問 GPU/CPU 資源造成衝突
- 確保推論結果的一致性

#### 3.4 保存操作並發控制

```csharp
// 控制同時保存的圖片數量（避免 I/O 阻塞）
private readonly SemaphoreSlim _cameraSaveSemaphore = 
    new SemaphoreSlim(Environment.ProcessorCount, Environment.ProcessorCount);

// 在保存前獲取信號量
await _cameraSaveSemaphore.WaitAsync();
try
{
    image.Save(outputPath, encodedFormat, 80);
}
finally
{
    _cameraSaveSemaphore.Release();
}
```

**為什麼需要保存信號量？**
- 限制同時進行的 I/O 操作數量
- 避免大量並發寫入造成磁碟 I/O 阻塞
- 根據 CPU 核心數動態調整並發數

### 4. 執行緒生命週期

#### 4.1 相機連接

```
用戶點擊「連接相機」
    ↓
UI 執行緒：創建 VideoCaptureDevice
    ↓
UI 執行緒：註冊 NewFrame 事件
    ↓
AForge 內部：啟動相機驅動執行緒
    ↓
持續運行：AForge 執行緒捕獲畫面並觸發事件
```

#### 4.2 相機斷開

```
用戶點擊「斷開相機」或切換模式
    ↓
UI 執行緒：停止 VideoCaptureDevice
    ↓
AForge 內部：停止相機驅動執行緒
    ↓
UI 執行緒：清理資源（釋放 Bitmap）
    ↓
UI 執行緒：更新 UI 狀態
```

#### 4.3 拍照處理

```
用戶點擊「拍照檢測」
    ↓
UI 執行緒：驗證狀態、獲取畫面快照
    ↓
背景執行緒：轉換圖片格式
    ↓
背景執行緒：獲取推論鎖、執行推論
    ↓
背景執行緒：繪製結果、保存圖片
    ↓
UI 執行緒（透過 InvokeUI）：更新統計、顯示結果
```

### 5. 性能優化

#### 5.1 畫面預覽優化

- **畫面緩衝**：使用 `_currentCameraFrame` 緩存最新畫面，避免頻繁複製
- **異步更新**：使用 `InvokeUI` 異步更新 UI，不阻塞相機執行緒
- **資源管理**：及時釋放舊的 Bitmap，避免記憶體洩漏

#### 5.2 連拍優化

- **並行處理**：多張圖片並行處理，不阻塞拍攝循環
- **時間控制**：精確控制拍攝間隔，確保 1 秒內均勻分布
- **資源限制**：使用信號量限制並發數，避免資源耗盡

#### 5.3 推論優化

- **單一推論**：使用推論門閥確保同一時間只有一個推論
- **異步處理**：推論在背景執行緒執行，不阻塞 UI
- **結果緩存**：處理結果緩存在 `_resultBitmaps`，支持快速瀏覽

### 6. 錯誤處理

#### 6.1 相機連接失敗

```csharp
try
{
    _videoSource = new VideoCaptureDevice(monikerString);
    _videoSource.Start();
}
catch (Exception ex)
{
    InvokeUI(() =>
    {
        AddLog($"相機連接失敗: {ex.Message}");
        MessageBox.Show(...);
    });
}
```

#### 6.2 畫面處理錯誤

```csharp
try
{
    Bitmap? clonedFrame = (Bitmap)eventArgs.Frame.Clone();
    // ... 處理畫面
}
catch
{
    clonedFrame?.Dispose();
    return; // 忽略單次錯誤，不影響後續處理
}
```

#### 6.3 推論錯誤

```csharp
try
{
    await _inferenceGate.WaitAsync();
    results = _yolo!.RunSegmentation(skBitmap, ...);
}
catch (Exception ex)
{
    InvokeUI(() =>
    {
        AddLog($"推論失敗: {ex.Message}");
    });
}
finally
{
    _inferenceGate.Release(); // 確保釋放鎖
}
```

### 7. 資源清理

#### 7.1 相機斷開時

```csharp
private void DisconnectCamera()
{
    if (_videoSource != null)
    {
        _videoSource.SignalToStop();
        _videoSource.WaitForStop();
        _videoSource.NewFrame -= VideoSource_NewFrame;
        _videoSource.Dispose();
        _videoSource = null;
    }
    
    lock (_cameraFrameLock)
    {
        _currentCameraFrame?.Dispose();
        _currentCameraFrame = null;
    }
}
```

#### 7.2 窗體關閉時

```csharp
protected override void OnFormClosing(FormClosingEventArgs e)
{
    // 停止相機
    DisconnectCamera();
    
    // 釋放模型
    _yolo?.Dispose();
    
    // 釋放所有 Bitmap
    ClearResultBitmaps();
    
    base.OnFormClosing(e);
}
```

## 總結

相機功能採用多執行緒架構，確保：

1. **UI 響應性**：所有耗時操作在背景執行緒執行
2. **線程安全**：使用鎖和信號量保護共享資源
3. **性能優化**：並行處理、資源限制、異步更新
4. **錯誤處理**：完善的異常處理機制
5. **資源管理**：及時釋放資源，避免記憶體洩漏

這種設計確保了相機功能在保持高效能的同時，維持系統的穩定性和響應性。
