# 工業產品表面缺陷檢測系統 - 執行緒原理說明

## 概述

本系統採用多層執行緒架構，實現高效、穩定的並發處理能力。核心設計理念是**解耦事件監聽與實際處理邏輯**，通過 Producer/Consumer 模式、信號量控制、線程安全機制等技術，確保系統在高併發場景下的穩定運行。

---

## 執行緒架構圖

```
┌─────────────────────────────────────────────────────────────┐
│                    UI 執行緒 (主執行緒)                      │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  FileSystemWatcher (事件監聽器)                      │   │
│  │  - 監控目錄創建事件                                    │   │
│  │  - 觸發時：將任務加入 Channel 佇列 (Producer)        │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ 寫入任務
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              Channel<MonitorWorkItem> (無界佇列)            │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  - SingleReader = true (單一消費者)                   │   │
│  │  - SingleWriter = false (多個生產者)                  │   │
│  │  - 線程安全的 FIFO 佇列                              │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ 讀取任務
                            ▼
┌─────────────────────────────────────────────────────────────┐
│          背景工作執行緒 (MonitorWorkerLoopAsync)            │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  1. 從 Channel 讀取任務                               │   │
│  │  2. 檢查去重 (ConcurrentDictionary)                   │   │
│  │  3. 調用 ProcessMaterialDirectory                     │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ 處理圖片
                            ▼
┌─────────────────────────────────────────────────────────────┐
│         Task.Run 執行緒池 (ProcessMaterialDirectory)        │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  1. 等待檔案就緒 (WaitFileReadyAsync)                 │   │
│  │  2. 獲取推論門閥 (SemaphoreSlim)                      │   │
│  │  3. 執行 YOLO 推論 (單一執行緒保護)                    │   │
│  │  4. 釋放推論門閥                                       │   │
│  │  5. 更新 UI (InvokeUI)                                │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 核心組件詳解

### 1. Producer/Consumer 模式

#### 1.1 Channel 佇列

```csharp
private readonly Channel<MonitorWorkItem> _monitorQueue = Channel.CreateUnbounded<MonitorWorkItem>(
    new UnboundedChannelOptions { SingleReader = true, SingleWriter = false });
```

**設計特點：**
- **無界佇列**：`CreateUnbounded` 表示佇列容量無限制，不會因佇列滿而阻塞
- **單一消費者**：`SingleReader = true` 確保只有一個背景工作執行緒處理任務，保證順序性
- **多個生產者**：`SingleWriter = false` 允許多個 `FileSystemWatcher` 事件同時寫入

**工作原理：**
1. **生產者端**（UI 執行緒）：
   ```csharp
   private void EnqueueMaterialWork(string materialDirPath, string reason)
   {
       _monitorQueue.Writer.TryWrite(new MonitorWorkItem(materialDirPath, reason));
   }
   ```
   - `FileSystemWatcher.Created` 事件觸發時，在 UI 執行緒中調用此方法
   - `TryWrite` 是同步、非阻塞操作，立即返回
   - 不會阻塞 UI 執行緒

2. **消費者端**（背景執行緒）：
   ```csharp
   private async Task MonitorWorkerLoopAsync(CancellationToken ct)
   {
       await foreach (var item in _monitorQueue.Reader.ReadAllAsync(ct))
       {
           // 處理任務
       }
   }
   ```
   - 使用 `async foreach` 異步迭代，當佇列為空時自動等待
   - `ReadAllAsync` 會阻塞直到有新任務或取消令牌被觸發

#### 1.2 背景工作執行緒啟動

```csharp
private void EnsureMonitorWorkerStarted()
{
    if (_monitorWorkerTask != null && !_monitorWorkerTask.IsCompleted) return;
    
    _monitorCts?.Cancel();
    _monitorCts?.Dispose();
    _monitorCts = new CancellationTokenSource();
    
    _monitorWorkerTask = Task.Run(() => MonitorWorkerLoopAsync(_monitorCts.Token));
}
```

**執行流程：**
1. 檢查是否已有運行中的工作執行緒
2. 如果存在舊的取消令牌，先取消並釋放
3. 創建新的取消令牌
4. 使用 `Task.Run` 在執行緒池中啟動背景工作

---

### 2. 去重機制

```csharp
private readonly ConcurrentDictionary<string, byte> _inFlightMaterials = 
    new(StringComparer.OrdinalIgnoreCase);
```

**問題背景：**
- `FileSystemWatcher` 可能因為檔案系統事件抖動，對同一目錄觸發多次 `Created` 事件
- 如果沒有去重，同一料號目錄可能被處理多次

**解決方案：**
```csharp
// 在 MonitorWorkerLoopAsync 中
if (!_inFlightMaterials.TryAdd(item.MaterialDirPath, 0))
    continue;  // 如果已存在，跳過此任務

try
{
    await ProcessMaterialDirectory(item.MaterialDirPath, ct);
}
finally
{
    _inFlightMaterials.TryRemove(item.MaterialDirPath, out _);
}
```

**工作原理：**
1. `TryAdd` 是原子操作，只有當鍵不存在時才會添加並返回 `true`
2. 如果返回 `false`，表示該料號正在處理中，直接跳過
3. 處理完成後，在 `finally` 中移除，確保即使發生異常也能正確清理

---

### 3. 推論門閥（Inference Gate）

```csharp
private readonly SemaphoreSlim _inferenceGate = new(1, 1);
```

**問題背景：**
- YOLO 模型不是線程安全的，多個執行緒同時調用可能導致：
  - 記憶體競爭
  - 模型狀態混亂
  - 推論結果錯誤

**解決方案：**
```csharp
// 在處理每張圖片時
await _inferenceGate.WaitAsync(ct);  // 獲取信號量（最多等待 1 個）
List<SegmentationBoundingBox> results;
try
{
    results = _yolo!.RunSegmentation(image, confidence, pixelConfidence, iou);
}
finally
{
    _inferenceGate.Release();  // 釋放信號量
}
```

**工作原理：**
1. **信號量初始化**：`new SemaphoreSlim(1, 1)` 表示最多允許 1 個執行緒同時持有
2. **等待機制**：`WaitAsync` 是異步等待，不會阻塞執行緒池
   - 如果信號量可用，立即獲取並繼續
   - 如果已被占用，等待直到其他執行緒釋放
3. **保證釋放**：使用 `try-finally` 確保即使發生異常也會釋放信號量

**執行時序示例：**
```
時間軸 →
Thread 1: [WaitAsync] ──────[推論]──────[Release]
Thread 2:        [WaitAsync]──────[等待]──────[推論]──────[Release]
Thread 3:                    [WaitAsync]──────[等待]──────[等待]──────[推論]
```

---

### 4. 線程安全的 UI 更新

```csharp
private void InvokeUI(Action action)
{
    if (InvokeRequired)
    {
        Invoke(action);  // 切換到 UI 執行緒執行
    }
    else
    {
        action();  // 已在 UI 執行緒，直接執行
    }
}
```

**問題背景：**
- Windows Forms 要求所有 UI 操作必須在 UI 執行緒（主執行緒）上執行
- 從背景執行緒直接更新 UI 會導致：
  - `InvalidOperationException`
  - UI 更新失敗或顯示異常

**解決方案：**
- `InvokeRequired` 檢查當前是否在 UI 執行緒
- 如果不是，使用 `Invoke` 將操作封送到 UI 執行緒執行
- `Invoke` 是同步操作，會阻塞調用執行緒直到 UI 執行緒完成操作

**使用範例：**
```csharp
// 在背景執行緒中
InvokeUI(() =>
{
    currentFileLabel.Text = $"當前文件: {fileName}";
    AddLog($"處理: {fileName}");
    statusLabel.Text = $"正在處理: {fileName}";
});
```

---

### 5. 檔案就緒等待機制

```csharp
private static async Task WaitFileReadyAsync(string path, CancellationToken ct)
{
    const int maxTry = 80;  // 最多嘗試 80 次
    const int delayMs = 100; // 每次間隔 100ms
    
    long lastSize = -1;
    for (int i = 0; i < maxTry; i++)
    {
        ct.ThrowIfCancellationRequested();
        
        try
        {
            var fi = new FileInfo(path);
            if (!fi.Exists)
            {
                await Task.Delay(delayMs, ct);
                continue;
            }
            
            // 檔案大小需穩定（避免邊寫邊讀）
            if (fi.Length == lastSize)
            {
                // 嘗試以讀取模式開啟，確認寫入鎖已釋放
                using var _ = new FileStream(path, FileMode.Open, 
                                           FileAccess.Read, FileShare.Read);
                return;  // 檔案已就緒
            }
            
            lastSize = fi.Length;  // 記錄當前大小
        }
        catch
        {
            // 檔案仍在寫入或鎖定中
        }
        
        await Task.Delay(delayMs, ct);
    }
    
    throw new IOException($"File not ready: {path}");
}
```

**問題背景：**
- 當 `FileSystemWatcher` 檢測到新檔案時，檔案可能仍在寫入中
- 如果立即讀取，可能讀到：
  - 不完整的檔案
  - 損壞的圖片數據
  - 檔案鎖衝突

**解決方案：**
1. **檔案存在檢查**：確認檔案已創建
2. **大小穩定性檢查**：等待檔案大小不再變化（表示寫入完成）
3. **檔案鎖檢查**：嘗試以讀取模式開啟，確認寫入鎖已釋放
4. **超時保護**：最多等待 8 秒（80 × 100ms），避免無限等待
5. **異步非阻塞**：使用 `Task.Delay` 而非 `Thread.Sleep`，不阻塞執行緒池

---

### 6. 取消令牌機制

```csharp
private CancellationTokenSource? _cancellationTokenSource;
private CancellationTokenSource? _monitorCts;
```

**使用場景：**

1. **手動處理模式取消**：
   ```csharp
   private void StopButton_Click(object sender, EventArgs e)
   {
       _cancellationTokenSource?.Cancel();  // 觸發取消
   }
   ```

2. **監控模式停止**：
   ```csharp
   private void StopMonitorButton_Click(object sender, EventArgs e)
   {
       _monitorCts?.Cancel();  // 取消背景工作
   }
   ```

3. **在處理循環中檢查**：
   ```csharp
   foreach (var imagePath in allImageFiles)
   {
       ct.ThrowIfCancellationRequested();  // 如果已取消，拋出異常
       // ... 處理圖片
   }
   ```

**工作原理：**
- `CancellationTokenSource` 是取消操作的源頭
- `CancellationToken` 是傳遞給異步操作的令牌
- 調用 `Cancel()` 後，所有檢查 `ThrowIfCancellationRequested()` 的地方都會拋出 `OperationCanceledException`
- 通過 `try-catch` 捕獲此異常，實現優雅的取消

---

## 完整執行流程

### 監控模式流程

```
1. 用戶點擊「開始監控」
   └─> 初始化 YOLO 模型
   └─> 啟動 FileSystemWatcher
   └─> 調用 EnsureMonitorWorkerStarted()
       └─> 啟動 MonitorWorkerLoopAsync 背景執行緒

2. FileSystemWatcher 檢測到新目錄
   └─> FileSystemWatcher_Created 事件（UI 執行緒）
       └─> EnqueueMaterialWork() 將任務加入 Channel

3. MonitorWorkerLoopAsync 背景執行緒
   └─> 從 Channel 讀取任務
   └─> 檢查去重（ConcurrentDictionary）
   └─> 調用 ProcessMaterialDirectory()
       └─> Task.Run 在執行緒池中執行
           └─> 遍歷所有圖片
               └─> WaitFileReadyAsync() 等待檔案就緒
               └─> 獲取推論門閥（SemaphoreSlim）
               └─> 執行 YOLO 推論
               └─> 釋放推論門閥
               └─> InvokeUI() 更新 UI
```

### 執行緒交互時序圖

```
UI Thread          Channel Queue        Worker Thread        Thread Pool
    │                    │                    │                  │
    │─FileSystemWatcher─>│                    │                  │
    │  Created Event     │                    │                  │
    │                    │                    │                  │
    │─EnqueueMaterial───>│                    │                  │
    │  (TryWrite)        │                    │                  │
    │                    │                    │                  │
    │                    │<─ReadAllAsync──────│                  │
    │                    │  (await foreach)   │                  │
    │                    │                    │                  │
    │                    │                    │─ProcessMaterial─>│
    │                    │                    │  Directory       │
    │                    │                    │                  │
    │                    │                    │                  │─WaitFileReady
    │                    │                    │                  │─WaitAsync(Gate)
    │                    │                    │                  │─RunSegmentation
    │                    │                    │                  │─Release(Gate)
    │                    │                    │                  │
    │<─InvokeUI──────────│                    │<─InvokeUI────────│
    │  (Update UI)       │                    │  (Update UI)     │
```

---

## 關鍵設計決策

### 1. 為什麼使用 Channel 而不是 Queue？

- **異步支持**：Channel 原生支持 `async/await`，更適合異步場景
- **背壓處理**：可以配置有界佇列，當佇列滿時自動阻塞生產者
- **取消支持**：`ReadAllAsync` 支持 `CancellationToken`，優雅取消
- **性能優化**：內部實現更高效，減少鎖競爭

### 2. 為什麼使用 SemaphoreSlim 而不是 lock？

- **異步支持**：`WaitAsync` 是異步的，不會阻塞執行緒池
- **超時支持**：可以設置等待超時時間
- **取消支持**：`WaitAsync` 支持 `CancellationToken`
- **可配置性**：可以設置允許的並發數量（雖然這裡是 1）

### 3. 為什麼使用 ConcurrentDictionary 而不是 Dictionary + lock？

- **性能**：`ConcurrentDictionary` 使用細粒度鎖，減少鎖競爭
- **線程安全**：所有操作都是原子性的，無需額外加鎖
- **簡潔性**：代碼更簡潔，不需要手動管理鎖

### 4. 為什麼使用 Task.Run 而不是直接 async？

- **執行緒隔離**：確保圖片處理在執行緒池中執行，不阻塞背景工作執行緒
- **並發控制**：可以更好地控制並發數量
- **資源管理**：執行緒池自動管理執行緒生命週期

---

## 性能優化要點

1. **非阻塞設計**：所有等待操作都使用異步方法，不阻塞執行緒
2. **執行緒池利用**：充分利用 .NET 執行緒池，避免創建過多執行緒
3. **去重機制**：避免重複處理，節省計算資源
4. **推論串行化**：雖然推論是串行的，但檔案 I/O 和其他操作可以並行
5. **UI 更新批處理**：通過 `InvokeUI` 統一管理，減少執行緒切換開銷

---

## 潛在問題與解決方案

### 問題 1：Channel 佇列積壓

**現象**：處理速度跟不上事件產生速度，佇列不斷增長

**解決方案**：
- 可以改用有界 Channel：`Channel.CreateBounded<MonitorWorkItem>(capacity)`
- 當佇列滿時，`TryWrite` 返回 `false`，可以記錄警告或丟棄任務

### 問題 2：推論門閥成為瓶頸

**現象**：多個料號同時處理時，推論操作串行執行，效率低

**解決方案**：
- 如果 YOLO 模型支持多實例，可以創建多個模型實例
- 使用多個信號量，每個模型實例一個

### 問題 3：記憶體使用過高

**現象**：處理大量圖片時，記憶體持續增長

**解決方案**：
- 及時釋放圖片資源（使用 `using` 語句）
- 限制同時處理的料號數量
- 定期清理結果緩存

---

## 總結

本系統的執行緒架構通過以下核心機制實現高效、穩定的並發處理：

1. **Producer/Consumer 模式**：解耦事件監聽與處理邏輯
2. **推論門閥**：確保模型推論的線程安全
3. **去重機制**：避免重複處理
4. **線程安全的 UI 更新**：確保 UI 操作正確執行
5. **檔案就緒等待**：避免讀取不完整檔案
6. **取消令牌**：支持優雅取消

這些機制共同工作，確保系統在高併發場景下能夠穩定運行，同時保持 UI 的響應性。
